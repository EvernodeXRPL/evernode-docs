{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Evernode Evernode is a decentralized marketplace for hosting smart contracts. Evernode brings several decentralized technology innovations together to provide a global network of severs which is capable of hosting smart contracts. It consists of Hosts , which are Linux servers capable of hosting smart contracts; Registry , which maintains a directory of participating hosts; and Tenants who purchase server space from Hosts in order to run smart contracts. The interactions and the financial activities between these parties are facilitated by the XRP Ledger . Financial model Evernode finances are modeled using XRPL tokens . Evernode uses Evers (EVR) as its native currency for all financial transactions in the marketplace. Evers are issued by the Evernode Foundation and is guaranteed to be finite in supply. Hosts pay their registration fee in Evers. Hosts value their server space against Evers. Tenants can lease hosting using Evers. The initial phase of Evernode will see to it that a portion of the limited Ever supply find its way to the hands of the community by means of airdrops. The community can use these Evers to register as Hosts or to lease hosting as Tenants from registered Hosts. The rest will be progressively distributed by the Evernode Purchaser Service , as perpetual hosting lease payments to all registered Hosts in order to host the Community Contract . This ensures early participants of the network will have a steady income for making their server space available on Evernode. See Evernode tokenomics . Further reading Registry Hosts Tenants Purchaser service Evernode tokenomics Sashimono Hot Pocket Evernode news @EvernodeXRPL on Twitter Evernode website","title":"Evernode"},{"location":"#evernode","text":"Evernode is a decentralized marketplace for hosting smart contracts. Evernode brings several decentralized technology innovations together to provide a global network of severs which is capable of hosting smart contracts. It consists of Hosts , which are Linux servers capable of hosting smart contracts; Registry , which maintains a directory of participating hosts; and Tenants who purchase server space from Hosts in order to run smart contracts. The interactions and the financial activities between these parties are facilitated by the XRP Ledger .","title":"Evernode"},{"location":"#financial-model","text":"Evernode finances are modeled using XRPL tokens . Evernode uses Evers (EVR) as its native currency for all financial transactions in the marketplace. Evers are issued by the Evernode Foundation and is guaranteed to be finite in supply. Hosts pay their registration fee in Evers. Hosts value their server space against Evers. Tenants can lease hosting using Evers. The initial phase of Evernode will see to it that a portion of the limited Ever supply find its way to the hands of the community by means of airdrops. The community can use these Evers to register as Hosts or to lease hosting as Tenants from registered Hosts. The rest will be progressively distributed by the Evernode Purchaser Service , as perpetual hosting lease payments to all registered Hosts in order to host the Community Contract . This ensures early participants of the network will have a steady income for making their server space available on Evernode. See Evernode tokenomics .","title":"Financial model"},{"location":"#further-reading","text":"Registry Hosts Tenants Purchaser service Evernode tokenomics Sashimono Hot Pocket","title":"Further reading"},{"location":"#evernode-news","text":"@EvernodeXRPL on Twitter Evernode website","title":"Evernode news"},{"location":"hosts/","text":"Hosts An Evernode host is a Linux server registered on the Evernode Registry via an XRPL account owned and controlled by the host. The server runs a piece of Evernode software to open up the server hardware resources in a secure manner for Evernode Tenants to host their smart contracts. Registration The host registers on Evernode Registry by paying the current registration fee with host metadata included in the payment transaction. Host metadata contains information such host server location and hardware resources. The XRPL account used to make the registration payment is considered the Host account . This account's address identifies the host within Evernode. Once the registration fee is paid, Evernode registry issues a Registration NFT to the host account. The Registration NFT acts as proof-of-membership of that host within Evernode. The host can sell the NFT back to Evernode Registry for half of prevailing registration fee at a later time. Upon this act, the registry will deregister the host from the membership registry. Hosting slices A host can choose what amount of its total hardware resources (CPU, RAM, Disk space) is allocated for Evernode smart contract hosting. This resource allocation is further divided into a number of equal-sized \"slices\" chosen by the host. These hosting slices correspond to potential smart contract instances tenants can purchase (1 slice = 1 instance). They are just a numerical division of the host's total allocated hardware resources and are only actually utilized when smart contract instances get materialized as a result of a tenant acquiring a lease. Eech hosting slice is represented using a Hosting NFT which can be bought for Evers which signifies a lease acquisition. Hosting NFTs The host mints and offers hosting NFTs to represent all hosting slices on the host (N slices = N nfts). Hosting NFTs are always priced at the Lease amount in Evers, the price of hosting a smart contract for 1 Moment . A tenant must purchase a hosting NFTs in order to own a smart contract instance. Upon purchase, the tenant has essentially acquired a lease of a hosting slice which is due to expire in 1 Moment. The tenant can extend the lease by paying sufficient Evers to lease any number of future Moments in advance (lease amount = price of 1 Moment of hosting). Owning a hosting NFT means the right to own a smart contract instance for 1 Moment and the right to pay for future Moments of that instance. Moment \"Moment\" is the measure of time in Evernode. It is calcualted using \"XRPL ledgers elapsed\". Moment is the smallest duration that a smart contract instance can be paid and hosted for. Currently, a Moment is defined as 72 XRPL ledgers. Smart contract instances When a tenant acquires a lease (purchases a hosting NFT), the host provisions a default contract instance on a hosting slice. The instance is assigned a unique instance name , which is derived from the purchased NFT itself. This can be used to identify a particular instance within the host. This, along with other instance details such as communication port numbers and domain/ip addresses are returned back to the tenant who acquired the lease. Lifetime of the contrace instance is the lifetime of the lease. As long as the lease is being paid for, contract instance will continue to function. Lease acquisition automatically guarantees a lifetime of 1 Moment. Lifetime can be extended by paying corresponding amount of Evers as specified in lease amount (N x lease amount = N future Moments of lifetime). Then the lease expires, the host deletes the instance and that hosting slice becomes available for a new lease again. At this point, the host burns the existing hosting NFT and re-issues a new NFT to replace it. Sashimono is the software which manages the contract instances on the host. It is capable of listening to hosting NFT purchases (lease acquisitions) from Evernode tenants on the host's XRPL account and appropriately provisioning contract instances. It uses Docker to isolate contract instances from each other. After the tenant receives the instance details, direct communication with the instance can be initiated without going through XRP Ledger or Sashimono. To learn more about communicating with a contract instance, see Hot Pocket Installation Evernode setup makes the entire process of registering and participating as an Evernode host a hassle free experience. With a guided set of steps, it can automatically register a Linux host on Evernode registry and serve lease acquisitions from tenants. It also installs the ncessary tools for the host administrator to manage the contract instances that have been provisioned on the host.","title":"Hosts"},{"location":"hosts/#hosts","text":"An Evernode host is a Linux server registered on the Evernode Registry via an XRPL account owned and controlled by the host. The server runs a piece of Evernode software to open up the server hardware resources in a secure manner for Evernode Tenants to host their smart contracts.","title":"Hosts"},{"location":"hosts/#registration","text":"The host registers on Evernode Registry by paying the current registration fee with host metadata included in the payment transaction. Host metadata contains information such host server location and hardware resources. The XRPL account used to make the registration payment is considered the Host account . This account's address identifies the host within Evernode. Once the registration fee is paid, Evernode registry issues a Registration NFT to the host account. The Registration NFT acts as proof-of-membership of that host within Evernode. The host can sell the NFT back to Evernode Registry for half of prevailing registration fee at a later time. Upon this act, the registry will deregister the host from the membership registry.","title":"Registration"},{"location":"hosts/#hosting-slices","text":"A host can choose what amount of its total hardware resources (CPU, RAM, Disk space) is allocated for Evernode smart contract hosting. This resource allocation is further divided into a number of equal-sized \"slices\" chosen by the host. These hosting slices correspond to potential smart contract instances tenants can purchase (1 slice = 1 instance). They are just a numerical division of the host's total allocated hardware resources and are only actually utilized when smart contract instances get materialized as a result of a tenant acquiring a lease. Eech hosting slice is represented using a Hosting NFT which can be bought for Evers which signifies a lease acquisition.","title":"Hosting slices"},{"location":"hosts/#hosting-nfts","text":"The host mints and offers hosting NFTs to represent all hosting slices on the host (N slices = N nfts). Hosting NFTs are always priced at the Lease amount in Evers, the price of hosting a smart contract for 1 Moment . A tenant must purchase a hosting NFTs in order to own a smart contract instance. Upon purchase, the tenant has essentially acquired a lease of a hosting slice which is due to expire in 1 Moment. The tenant can extend the lease by paying sufficient Evers to lease any number of future Moments in advance (lease amount = price of 1 Moment of hosting). Owning a hosting NFT means the right to own a smart contract instance for 1 Moment and the right to pay for future Moments of that instance.","title":"Hosting NFTs"},{"location":"hosts/#moment","text":"\"Moment\" is the measure of time in Evernode. It is calcualted using \"XRPL ledgers elapsed\". Moment is the smallest duration that a smart contract instance can be paid and hosted for. Currently, a Moment is defined as 72 XRPL ledgers.","title":"Moment"},{"location":"hosts/#smart-contract-instances","text":"When a tenant acquires a lease (purchases a hosting NFT), the host provisions a default contract instance on a hosting slice. The instance is assigned a unique instance name , which is derived from the purchased NFT itself. This can be used to identify a particular instance within the host. This, along with other instance details such as communication port numbers and domain/ip addresses are returned back to the tenant who acquired the lease. Lifetime of the contrace instance is the lifetime of the lease. As long as the lease is being paid for, contract instance will continue to function. Lease acquisition automatically guarantees a lifetime of 1 Moment. Lifetime can be extended by paying corresponding amount of Evers as specified in lease amount (N x lease amount = N future Moments of lifetime). Then the lease expires, the host deletes the instance and that hosting slice becomes available for a new lease again. At this point, the host burns the existing hosting NFT and re-issues a new NFT to replace it. Sashimono is the software which manages the contract instances on the host. It is capable of listening to hosting NFT purchases (lease acquisitions) from Evernode tenants on the host's XRPL account and appropriately provisioning contract instances. It uses Docker to isolate contract instances from each other. After the tenant receives the instance details, direct communication with the instance can be initiated without going through XRP Ledger or Sashimono. To learn more about communicating with a contract instance, see Hot Pocket","title":"Smart contract instances"},{"location":"hosts/#installation","text":"Evernode setup makes the entire process of registering and participating as an Evernode host a hassle free experience. With a guided set of steps, it can automatically register a Linux host on Evernode registry and serve lease acquisitions from tenants. It also installs the ncessary tools for the host administrator to manage the contract instances that have been provisioned on the host.","title":"Installation"},{"location":"hosts/sashimono/","text":"Sashimono Sashimono is the software which runs on all Evernode hosts enabling them to participate in Evernode and provide smart contract hosting services to Evernode tenants. It is installed on a host via the Evernode setup . Sashimono performs several jobs: 1. Interact with the XRP Ledger on behalf of the host XRPL account. 2. Provision and manage smart contract instances as requested by tenants. 3. Perform routine tasks that are cruicial for the upkeep of your host on Evernode. XRPL integration Sashimono possesses access to the keys of the host's XRPL account which represents the host on Evernode registry. It uses the keys to interact with the XRP Ledger on behalf of the host account. It performs following activities on XRP Ledger. 1. Offers leases for contract instances by issuing hosting NFTs . 2. Serves lease acquisitions sent to the host account by Evernode tenants. 3. Ensure the current host status is reflected on the Evernode registry. Contract instance structure Sashimono provisions contract instances in response to leases acquired by tenants. Each leased instance consists of following components: Hot Pocket - Evernode's smart contract executation and consensus engine. hpws - WebSockets protocol software used by Hot Pocket. hpfs - Filesystem software based on FUSE used by Hot Pocket to maintain contract state and blockchain. Contract binaries - The smart contract application files provided by the tenant. Contract data - Persisted smart contract data (contract state) and blockchain data files. Different contract instances on the same host can be leased by different tenants. Hence, Sashimono ensures that the contract instances cannot interfere with each other or the host itself. For that, it uses Docker and Linux user account security to isolate contract instances from one another. Furthermore, it also makes sure that the smart contract itself cannot interfere with the infrastructure services within the instance such as Hot Pocket. The following diagram depicts how Sashimono structures the execution of different components of a contract instance. For each contract instance, Sashimono creates an unpriviledged Linux user and runs all the infrastructure components and custom contract binaries in the context of that tenant. This provides security isolation between components of different contract instances. Read more on Sashimono blog post","title":"Sashimono"},{"location":"hosts/sashimono/#sashimono","text":"Sashimono is the software which runs on all Evernode hosts enabling them to participate in Evernode and provide smart contract hosting services to Evernode tenants. It is installed on a host via the Evernode setup . Sashimono performs several jobs: 1. Interact with the XRP Ledger on behalf of the host XRPL account. 2. Provision and manage smart contract instances as requested by tenants. 3. Perform routine tasks that are cruicial for the upkeep of your host on Evernode.","title":"Sashimono"},{"location":"hosts/sashimono/#xrpl-integration","text":"Sashimono possesses access to the keys of the host's XRPL account which represents the host on Evernode registry. It uses the keys to interact with the XRP Ledger on behalf of the host account. It performs following activities on XRP Ledger. 1. Offers leases for contract instances by issuing hosting NFTs . 2. Serves lease acquisitions sent to the host account by Evernode tenants. 3. Ensure the current host status is reflected on the Evernode registry.","title":"XRPL integration"},{"location":"hosts/sashimono/#contract-instance-structure","text":"Sashimono provisions contract instances in response to leases acquired by tenants. Each leased instance consists of following components: Hot Pocket - Evernode's smart contract executation and consensus engine. hpws - WebSockets protocol software used by Hot Pocket. hpfs - Filesystem software based on FUSE used by Hot Pocket to maintain contract state and blockchain. Contract binaries - The smart contract application files provided by the tenant. Contract data - Persisted smart contract data (contract state) and blockchain data files. Different contract instances on the same host can be leased by different tenants. Hence, Sashimono ensures that the contract instances cannot interfere with each other or the host itself. For that, it uses Docker and Linux user account security to isolate contract instances from one another. Furthermore, it also makes sure that the smart contract itself cannot interfere with the infrastructure services within the instance such as Hot Pocket. The following diagram depicts how Sashimono structures the execution of different components of a contract instance. For each contract instance, Sashimono creates an unpriviledged Linux user and runs all the infrastructure components and custom contract binaries in the context of that tenant. This provides security isolation between components of different contract instances. Read more on Sashimono blog post","title":"Contract instance structure"},{"location":"hot-pocket/","text":"Hot Pocket Hot Pocket is a smart contract execution and consensus engine. Your can build your \"Smart Contract\" and run it on a distributed Hot Pocket cluster. Hot Pocket takes care of running instances of your smart contract on all the nodes and perform \"consensus\" on your smart contract executions. Smart Contract Hot Pocket defines the smart contract as a regular POSIX application that can receive Inputs , produce Outputs and also persist State to permenant storage. You can use any POSIX-compliant programming platform to create Hot Pocket smart contracts (see nodejs contract example ). Consensus Because your smart contract instances simultaneously runs on multiple nodes, it needs to be verified that all instances execute under exact same conditions and in the same manner. Hot Pocket makes sure that the MAJORITY of the instances receives the same inputs , produces same outputs and persists same state to the permanent storage. This is known as consensus in which majority of instances AGREE upon similar behavior of the smart contract. Security aspect The benefit of consensus is that in order for an intruder to arbitrarily change the behavior of the smart contract or to forcefully tamper the persisted state, they need to be able to do that to a MAJORITY of the instances at the same time, which is practically impossible. If one of the instances gets compromised, the consensus would detect it and apply corrections to the compromised instance. Decentralized control If different instances of the smart contract is owned by multiple parties (eg. different people or organizations), then no single party has ultimate control over the entire cluster. No single party can manipulate the system. It would require collaboration of majority of owners to manipulate the entire system's behaviour in order to make collective modifications to the instances owned by them at the same time . Users You can \"connect\" to any ONE of the smart contract instances of the cluster and communicate with that instance as a \"user\" (Hot Pocket will subject your communication with that particular instance to inter-node consensus which is hidden from you). For Hot Pocket to distinguish you with other users who are connecting to the same cluster, you need to identify yourself with a unique Public/Private asymmetric key pair (generated using EdDSA signing key algorithm). Upon successful connection, you can communicate with the smart contract using the app-specific message formats defined by the smart contract developer. Hot Pocket acts as a \"carrier\" of messages between you and the smart contract. See User connection basics Hot Pocket SDKs Hot Pocket provides several libraries to make it easy to write Hot Pocket smart contracts and to connect and communicate with Hot Pocket smart contracts as a user. Library for NodeJs contracts Library for Javascript clients","title":"Hot Pocket"},{"location":"hot-pocket/#hot-pocket","text":"Hot Pocket is a smart contract execution and consensus engine. Your can build your \"Smart Contract\" and run it on a distributed Hot Pocket cluster. Hot Pocket takes care of running instances of your smart contract on all the nodes and perform \"consensus\" on your smart contract executions.","title":"Hot Pocket"},{"location":"hot-pocket/#smart-contract","text":"Hot Pocket defines the smart contract as a regular POSIX application that can receive Inputs , produce Outputs and also persist State to permenant storage. You can use any POSIX-compliant programming platform to create Hot Pocket smart contracts (see nodejs contract example ).","title":"Smart Contract"},{"location":"hot-pocket/#consensus","text":"Because your smart contract instances simultaneously runs on multiple nodes, it needs to be verified that all instances execute under exact same conditions and in the same manner. Hot Pocket makes sure that the MAJORITY of the instances receives the same inputs , produces same outputs and persists same state to the permanent storage. This is known as consensus in which majority of instances AGREE upon similar behavior of the smart contract.","title":"Consensus"},{"location":"hot-pocket/#security-aspect","text":"The benefit of consensus is that in order for an intruder to arbitrarily change the behavior of the smart contract or to forcefully tamper the persisted state, they need to be able to do that to a MAJORITY of the instances at the same time, which is practically impossible. If one of the instances gets compromised, the consensus would detect it and apply corrections to the compromised instance.","title":"Security aspect"},{"location":"hot-pocket/#decentralized-control","text":"If different instances of the smart contract is owned by multiple parties (eg. different people or organizations), then no single party has ultimate control over the entire cluster. No single party can manipulate the system. It would require collaboration of majority of owners to manipulate the entire system's behaviour in order to make collective modifications to the instances owned by them at the same time .","title":"Decentralized control"},{"location":"hot-pocket/#users","text":"You can \"connect\" to any ONE of the smart contract instances of the cluster and communicate with that instance as a \"user\" (Hot Pocket will subject your communication with that particular instance to inter-node consensus which is hidden from you). For Hot Pocket to distinguish you with other users who are connecting to the same cluster, you need to identify yourself with a unique Public/Private asymmetric key pair (generated using EdDSA signing key algorithm). Upon successful connection, you can communicate with the smart contract using the app-specific message formats defined by the smart contract developer. Hot Pocket acts as a \"carrier\" of messages between you and the smart contract. See User connection basics","title":"Users"},{"location":"hot-pocket/#hot-pocket-sdks","text":"Hot Pocket provides several libraries to make it easy to write Hot Pocket smart contracts and to connect and communicate with Hot Pocket smart contracts as a user. Library for NodeJs contracts Library for Javascript clients","title":"Hot Pocket SDKs"},{"location":"hot-pocket/user-connections/","text":"Hot Pocket user connection basics Hot Pocket smart contracts are run as a cluster of nodes. As a user, you can connect to any one of the nodes and communicate with the smart contract. User public/private key pair You need to posses a unique public/private assymetric key pair generated using EdDSA signing key algorithm. You can use a suitable cryptographic library available on your platform in order to generate a key pair. Client libraries provided by Hot Pocket also contains helper methods which can do this. It is the user's responsibility to not let the \"Private Key\" get compromised. If that happens, anyone possessing your Private Key can pretend to be you. On the flip side, if you lose your Private Key, you will be unable to reclaim your user identity on the Hot Pocket platform Making a connection In order to initiate a connection to a smart contract instance, you need to know the address and the port number of where that instances is hosted. See this Javascript example on how to connect and communicate with a smart contract instance. Submitting inputs Hot Pocket defines \"Inputs\" as the messages you (user) send to the smart contract which has the potential to modify the smart contract state (similar to HTTP PUT/POST methods). \"Inputs\" are subjected to \"consensus\" (see Hot Pocket basics) and therefore may take longer to be processed. The reason being, even though you submitted the \"Input\" to a specific Hot Pocket instance (denoted by host address and port), it will propagate this to other nodes. As a group, all the instances in the cluster makes sure \"majority\" of them got the input. Once the above condition (majority instances has received your input) is met, you will get a \"Accepted\" response. This indicates your \"Input\" got accepted for processing by the entire cluster. However, there are various reasons that your \"Input\" can be \"Rejected\" as well which will not be explained here. Note: Unlike HTTP Rest APIs, it is wrong to assume every 'input' message will get a 'output' message as the response. It is up to the smart contract to decide whether to send a response message or not. If the smart contract actually sends such a response back, it will arrive much later than the \"Accepted\" response you got upon input submission. This is very different from how HTTP APIs work where a 'request' will get a immediate 'response'. This is mainly due to Hot Pocket operating on top of Web Sockets as opposed to HTTP. Receiving outputs \"Outputs\" are messages sent by the smart contract to the user. \"Outputs\" might be sent as a response to previously submitted \"Inputs\" or they might be delivered without any relationship to a previous \"Input\" (eg. periodic notification messages sent by a smart contract). It is up to the smart contract to decide when and where to send outputs. If the smart contract message format specifies that a particular input message will get a response, then it is up to you to wait and grab that response when it arrives. Hot Pocket client library makes this easy (see Javascript example for output capture ). Read requests Hot Pocket \"Read requests\" are very similar to HTTP GET method. They represent any messages that request information from the smart contract and that DOES NOT modify the smart contract state (read only). They are NOT subjected to consensus and are very much faster in their response time as opposed to \"Inputs/Outputs\". Unlike \"Inputs/Outputs\", Read Requests also follow similar request/response pattern like HTTP. Those qualities make them the ideal mechanism to read information out of the smart contract. Binary vs Text Protocols Hot Pocket supports binary vs text-mode communication protocols. If the smart contract uses text-based (eg. json) messages, then you should use the Hot Pocket json protocol. Otherwise Hot Pocket supports bson protocol. You can specify this in Hot Pocket client library ( Javascript example )","title":"Hot Pocket user connection basics"},{"location":"hot-pocket/user-connections/#hot-pocket-user-connection-basics","text":"Hot Pocket smart contracts are run as a cluster of nodes. As a user, you can connect to any one of the nodes and communicate with the smart contract.","title":"Hot Pocket user connection basics"},{"location":"hot-pocket/user-connections/#user-publicprivate-key-pair","text":"You need to posses a unique public/private assymetric key pair generated using EdDSA signing key algorithm. You can use a suitable cryptographic library available on your platform in order to generate a key pair. Client libraries provided by Hot Pocket also contains helper methods which can do this. It is the user's responsibility to not let the \"Private Key\" get compromised. If that happens, anyone possessing your Private Key can pretend to be you. On the flip side, if you lose your Private Key, you will be unable to reclaim your user identity on the Hot Pocket platform","title":"User public/private key pair"},{"location":"hot-pocket/user-connections/#making-a-connection","text":"In order to initiate a connection to a smart contract instance, you need to know the address and the port number of where that instances is hosted. See this Javascript example on how to connect and communicate with a smart contract instance.","title":"Making a connection"},{"location":"hot-pocket/user-connections/#submitting-inputs","text":"Hot Pocket defines \"Inputs\" as the messages you (user) send to the smart contract which has the potential to modify the smart contract state (similar to HTTP PUT/POST methods). \"Inputs\" are subjected to \"consensus\" (see Hot Pocket basics) and therefore may take longer to be processed. The reason being, even though you submitted the \"Input\" to a specific Hot Pocket instance (denoted by host address and port), it will propagate this to other nodes. As a group, all the instances in the cluster makes sure \"majority\" of them got the input. Once the above condition (majority instances has received your input) is met, you will get a \"Accepted\" response. This indicates your \"Input\" got accepted for processing by the entire cluster. However, there are various reasons that your \"Input\" can be \"Rejected\" as well which will not be explained here. Note: Unlike HTTP Rest APIs, it is wrong to assume every 'input' message will get a 'output' message as the response. It is up to the smart contract to decide whether to send a response message or not. If the smart contract actually sends such a response back, it will arrive much later than the \"Accepted\" response you got upon input submission. This is very different from how HTTP APIs work where a 'request' will get a immediate 'response'. This is mainly due to Hot Pocket operating on top of Web Sockets as opposed to HTTP.","title":"Submitting inputs"},{"location":"hot-pocket/user-connections/#receiving-outputs","text":"\"Outputs\" are messages sent by the smart contract to the user. \"Outputs\" might be sent as a response to previously submitted \"Inputs\" or they might be delivered without any relationship to a previous \"Input\" (eg. periodic notification messages sent by a smart contract). It is up to the smart contract to decide when and where to send outputs. If the smart contract message format specifies that a particular input message will get a response, then it is up to you to wait and grab that response when it arrives. Hot Pocket client library makes this easy (see Javascript example for output capture ).","title":"Receiving outputs"},{"location":"hot-pocket/user-connections/#read-requests","text":"Hot Pocket \"Read requests\" are very similar to HTTP GET method. They represent any messages that request information from the smart contract and that DOES NOT modify the smart contract state (read only). They are NOT subjected to consensus and are very much faster in their response time as opposed to \"Inputs/Outputs\". Unlike \"Inputs/Outputs\", Read Requests also follow similar request/response pattern like HTTP. Those qualities make them the ideal mechanism to read information out of the smart contract.","title":"Read requests"},{"location":"hot-pocket/user-connections/#binary-vs-text-protocols","text":"Hot Pocket supports binary vs text-mode communication protocols. If the smart contract uses text-based (eg. json) messages, then you should use the Hot Pocket json protocol. Otherwise Hot Pocket supports bson protocol. You can specify this in Hot Pocket client library ( Javascript example )","title":"Binary vs Text Protocols"},{"location":"purchaser/","text":"Not documented yet.","title":"Purchaser"},{"location":"registry/","text":"Registry Evernode registry maintains the membership listing of all the hosts that have registered on Evernode. It is also the central place of truth about the Evernode network configuration parameters. The hosts interact with the well-known XRPL account denoted by Registry Address which is controlled by the Evernode registry service. Tenants can use the registry to find out latest details about member hosts. Registry service interprits the membership management requests arriving at the registry XRPL account while maintaining a database of indexed membership and network configuration data. Tenants can use indexed data to find out information about registered Evernode hosts. For any party who wishes to interact with Evernode, Registry Address is the entry point into the Evernode network. Network configuration Evernode registry keeps several global configuration parameters that applies to the entire Evernode network in an accessible manner. Here are some of the important ones: Ever issuer address Ever issuance limit Current registration fee in Evers Moment duration Base market price of hosting leases Registry operations A new host requests for Evernode membership by initiating an XRPL payment of Evers equal to the current registration fee. Upon succesful processing, the registry service issues the Registration NFT to the host. The Registration NFT acts as proof-of-membership of that host within Evernode. The host can sell the NFT back to registry for half of prevailing registration fee at a later time. At this point, the registry service will deregister the host and clear the host data from the registry. Evernode tokenomics dictate that registration fee will reduce (halve) over time as the Host network gets crowded. Which such \"halving\" happens, all existing members are rebated the fee they are due. Future based on XRPL hooks In the future, when XRPL hooks amendment is finalized, it is anticipated that the Evernode registry service becomes a \"Hook\" on the XRP Ledger. WHen this happens, the host membership information can be read directly from the XRP Ledger by tenants.","title":"Registry"},{"location":"registry/#registry","text":"Evernode registry maintains the membership listing of all the hosts that have registered on Evernode. It is also the central place of truth about the Evernode network configuration parameters. The hosts interact with the well-known XRPL account denoted by Registry Address which is controlled by the Evernode registry service. Tenants can use the registry to find out latest details about member hosts. Registry service interprits the membership management requests arriving at the registry XRPL account while maintaining a database of indexed membership and network configuration data. Tenants can use indexed data to find out information about registered Evernode hosts. For any party who wishes to interact with Evernode, Registry Address is the entry point into the Evernode network.","title":"Registry"},{"location":"registry/#network-configuration","text":"Evernode registry keeps several global configuration parameters that applies to the entire Evernode network in an accessible manner. Here are some of the important ones: Ever issuer address Ever issuance limit Current registration fee in Evers Moment duration Base market price of hosting leases","title":"Network configuration"},{"location":"registry/#registry-operations","text":"A new host requests for Evernode membership by initiating an XRPL payment of Evers equal to the current registration fee. Upon succesful processing, the registry service issues the Registration NFT to the host. The Registration NFT acts as proof-of-membership of that host within Evernode. The host can sell the NFT back to registry for half of prevailing registration fee at a later time. At this point, the registry service will deregister the host and clear the host data from the registry. Evernode tokenomics dictate that registration fee will reduce (halve) over time as the Host network gets crowded. Which such \"halving\" happens, all existing members are rebated the fee they are due.","title":"Registry operations"},{"location":"registry/#future-based-on-xrpl-hooks","text":"In the future, when XRPL hooks amendment is finalized, it is anticipated that the Evernode registry service becomes a \"Hook\" on the XRP Ledger. WHen this happens, the host membership information can be read directly from the XRP Ledger by tenants.","title":"Future based on XRPL hooks"},{"location":"tenants/","text":"Not documented yet.","title":"Tenants"},{"location":"tokenomics/","text":"Not documented yet.","title":"Tokenomics"}]}