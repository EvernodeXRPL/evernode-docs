{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Evernode Evernode is a decentralized smart contract hosting platform composed with Hooks-enabled XRP Ledger . Evernode brings several decentralized technology innovations together to provide a global network of severs which is capable of hosting Hot Pocket smart contracts . Hot Pocket smart contracts Evernode uses Hot Pocket as its smart contract engine. Hot Pocket smart contracts are regular POSIX applications and can be written in any language. When multiple instances of a smart contract is deployed on a cluster of servers, Hot Pocket takes care of consensus and synchronization, letting the smart contract developer to only worry about the contract business logic. Evernode Hosts Evernode hosts are Linux servers acting as the decentralized infrastructure capable of hosting Hot Pocket smart contracts. Registered Evernode hosts can earn revenue by listing their hosting tokens on the XRPL dex so Evernode users can purchase and redeem the tokens to deploy smart contracts. Hosts will also get rewarded with EVR tokens, Evernode's native currency, as they get audited for QoS by Evernode Auditors. Anyone can become an Evernode host by installing Sashimono on their Linux server. See how to participate in Evernode beta Evernode Hook Evernode uses XRP Ledger with Hooks amendment as the glue to manage the decentralized hosting infrastructure and contract deployment requests. Evernode hook keeps track of registered hosts, QoS audits and hosting rewards. It also governs the servicing of smart contract hosting requests (redeems) submitted by Evernode users. See Evernode hook specification Evernode SDK Client or server-side applications can integrate with Evernode using the Evernode javascript client library . The library includes support for all Evernode operations .","title":"Home"},{"location":"#evernode","text":"Evernode is a decentralized smart contract hosting platform composed with Hooks-enabled XRP Ledger . Evernode brings several decentralized technology innovations together to provide a global network of severs which is capable of hosting Hot Pocket smart contracts .","title":"Evernode"},{"location":"#hot-pocket-smart-contracts","text":"Evernode uses Hot Pocket as its smart contract engine. Hot Pocket smart contracts are regular POSIX applications and can be written in any language. When multiple instances of a smart contract is deployed on a cluster of servers, Hot Pocket takes care of consensus and synchronization, letting the smart contract developer to only worry about the contract business logic.","title":"Hot Pocket smart contracts"},{"location":"#evernode-hosts","text":"Evernode hosts are Linux servers acting as the decentralized infrastructure capable of hosting Hot Pocket smart contracts. Registered Evernode hosts can earn revenue by listing their hosting tokens on the XRPL dex so Evernode users can purchase and redeem the tokens to deploy smart contracts. Hosts will also get rewarded with EVR tokens, Evernode's native currency, as they get audited for QoS by Evernode Auditors. Anyone can become an Evernode host by installing Sashimono on their Linux server. See how to participate in Evernode beta","title":"Evernode Hosts"},{"location":"#evernode-hook","text":"Evernode uses XRP Ledger with Hooks amendment as the glue to manage the decentralized hosting infrastructure and contract deployment requests. Evernode hook keeps track of registered hosts, QoS audits and hosting rewards. It also governs the servicing of smart contract hosting requests (redeems) submitted by Evernode users. See Evernode hook specification","title":"Evernode Hook"},{"location":"#evernode-sdk","text":"Client or server-side applications can integrate with Evernode using the Evernode javascript client library . The library includes support for all Evernode operations .","title":"Evernode SDK"},{"location":"evernode/hook-spec/","text":"Evernode hook specification The following sections describe the specification according to which the Evernode hook has been developed. The hook source code can be found here . Hook State Evernode hook makes use of xrpl hook state to store persistent or short-lived variables. We use a 2-byte prefix for all state keys to avoid key naming collisions in the future with other hooks (this is a best-practice). See state clobbering . Evernode state key format [EVERNODE(EVR)(3)][key type(1)][Specific key bytes(28)] The first three bytes identifies that this is an Evernode state key. Fourth byte identifies the key type within Evernode. Rest of the 28 bytes contain the bytes specific for the key. Singleton state keys Description Key Host count (Maintains total no. of registered hosts) STK_HOST_COUNT = EVR[50]00000.... Auditor count (Maintains total no. of registered auditors) STK_AUDITOR_COUNT = EVR[51]00000.... Ledger index when the CONF_MOMENT_SIZE last changed on STK_MOMENT_BASE_IDX = EVR[52]0000.... Moment start index and the moment seed(ledger hash) for the current moment STK_MOMENT_SEED = EVR[53]0000.... Last moment start index where rewards have been accumulated STK_ACCUMULATED_MOMENT_IDX = EVR[54]0000.... Pool of reward amounts which are received on a audit failure STK_REWARD_POOL = EVR[55]0000.... Repetitive state keys Description Prefix Configuration keys (Holds paramateres tunable by governance game) STP_CONF = EVR[1]... Host id keys (Host registration entries for id-based lookup) STP_HOST_ID = EVR[2]... Host address keys (Host registration entries for xrpl address-based lookup) STP_HOST_ADDR = EVR[3]... Auditor id keys (Auditor registration entries for id-based lookup) STP_AUDITOR_ID = EVR[4]... Auditor address keys (Auditor registration entries for xrpl address-based lookup) STP_AUDITOR_ADDR = EVR[5]... Redeem operation keys (Keys to hold ongoing redeem opration statuses) STP_REDEEM_OP = EVR[6]... Hook Configuration Evernode hook defines a set of tunable configuration parameters to govern the rules of the system. They are implemented as xrpl hook sate objects. They can be changed in a decentralized manner via the governance game. Configuration Default value State key No. of ledgers per moment DEF_MOMENT_SIZE = 72 CONF_MOMENT_SIZE = 0x0001 No. of Evers that will be ever issued. DEF_MINT_LIMIT = 25804800 CONF_MINT_LIMIT = 0x0002 The host registration fee in Evers. DEF_HOST_REG_FEE = 5 CONF_HOST_REG_FEE = 0x0003 The minimum amount of hosting token spending allowed in a redeem operation. DEF_MIN_REDEEM = 12 CONF_MIN_REDEEM = 0x0004 Max no. of ledgers within which a redeem operation has to be serviced. DEF_REDEEM_WINDOW = 24 CONF_REDEEM_WINDOW = 0x0005 No. of Evers rewarded per moment. DEF_REWARD = 64 CONF_REWARD = 0x0006 Max no. of rewards per moment. DEF_MAX_REWARDS = 20 CONF_MAX_REWARD = 0x0007 No. of maximum hosts that can be audited by a audit per moment. DEF_MAX_AUDIT = 5 CONF_MAX_AUDIT = 0x0008 Moment frequency which host should keep recharging the hook (which used to track host aliveness). DEF_HOST_HEARTBEAT_FREQ = 1 CONF_HOST_HEARTBEAT_FREQ = 0x0009 Default auditor address DEF_AUDITOR_ADDR = 0x...xrpadrress bytes... N/A About configuration state keys State keys must be 32 bytes long. Therefore we must 'pad' the configuration state keys with zeros to fit 32 bytes. Therefore actual state key for a given configuration must be derived from a macro like this: CONF_KEY(buf, confKey) // which expands to: STATE_KEY(buf, prefix, key, keyLen) // which expands to: buf = prefix + pad + key About default values Because the state values can only be \"initialized\" the first time they are used during a transaction processing, the default values must exist within the hook code. If a particular configuration value does not exist on the state, it has to be created with the default value indicated on the code. System Operations Evernode uses XRPL transactions with attached memos to incorporate Evernode operation payloads. Evernode defines following operations. 1. Host Registration Transaction type: Payment Source: Host Destination: Hook Currency: EVR Min amount: CONF_HOST_REG_FEE Memo: Type: evnHostReg Format: text/plain Data: <hosting_token (UPPERCASE, 3 chars)>;<country_code (2 chars)>;<cpu_micro_sec (positive integer)>;<ram_mb (positive integer)>;<disk_mb (positive integer)>;<description (26 chars)> Generated transactions: Transaction type: Trust Set Source: Hook Destination: Host Currency: hosting_token Limit: 999999999 Added state: Key: STP_HOST_ID + host_count + 1 value: <host_address(20)> Key: STP_HOST_ADDR + host_address Value: <host_id(4)><hosting_token(3)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><reserved(8)><description(26)> Note: The first audit cycle and redeem will append <audit_assigned_moment_start_idx(8)><auditor_addr(20)><rewarded_moment_start_idx(8)><accumulated_reward(8)><locked_token_amount(8)><last_heartbeat_ledger_idx(8)> to this state value. Modified state: Key: STK_HOST_COUNT Value: <new_host_count(4)> 2. Host deregistration Transaction type: Payment Source: Host Destination: Hook Currency: XRP Amount: Any Memo: Type: evnHostDereg Format: any Data: any Generated transactions: Transaction type: Payment Source: Hook Destination: Host Currency: hosting_token Amount: Available balance Transaction type: Trust Set Source: Hook Destination: Host Currency: hosting_token Limit: 0 Modified state: Key: STP_HOST_ID + deleted_host_id Value: <last_host_addr> Key: STP_HOST_ADDR + last_host_addr Value: <deleted_host_id(4)><...> Key: STK_HOST_COUNT Value: host_count - 1 Deleted state: Key: STP_HOST_ADDR + host_address Key: STP_HOST_ID + last_host_id 3. Redeem Transaction type: Payment Source: User Destination: Hook Currency: Anything other than XRP or EVR Min amount: CONF_MIN_REDEEM Memo: Type: evnRedeem Format: base64 Data: <encrypted instance requirements> Generated transactions: Transaction type: Payment Source: Hook Destination: Host Currency: XRP Amount: any Memo 1: Type: evnRedeem Format: base64 Data: <encrypted instance requirements> Memo 2: Type: evnRedeemOrigin Format: hex Data: <user_addr(20)<amount(8)><hosting_token(3)><redeem_tx_hash(32)> Added state: Key: STP_REDEEM_OP + Redeem tx hash Value: <hosting_token(3)><amount(8)><host_addr(20)><lcl_index(8)><user_addr(20)> Modified state: Key: STP_HOST_ADDR + host_addr Value: <host_id(4)><hosting_token(3)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><reserved(8)><description(26)><audit_assigned_moment_start_idx(8)><auditor_addr(20)><rewarded_moment_start_idx(8)><accumulated_reward(8)><locked_token_amount(8)><last_heartbeat_ledger_idx(8)> Note: <locked_token_amount(8)> += <amount(8)> 4. Redeem Success Transaction type: Payment Source: Host Destination: Hook Currency: XRP Amount: any Memo 1: Type: evnRedeemSuccess Format: base64 Data: <encrypted instance_data> Memo 2: Type: evnRedeemRef Format: hex Data: <redeem tx hash> Generated transactions: Transaction type: Payment Source: Hook Destination: User Currency: XRP Amount: any Memo 1: Type: evnRedeemSuccess Format: base64 Data: <encrypted instance_data> Memo 2: Type: evnRedeemRef Format: hex Data: <redeem tx hash> Transaction type: Payment Source: Hook Destination: Host Currency: <hosting_token> Amount: <redeemed amount> Deleted state: Key: STP_REDEEM_OP + Redeem tx hash Modified state: Key: STP_HOST_ADDR + host_addr Value: <host_id(4)><hosting_token(3)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><reserved(8)><description(26)><audit_assigned_moment_start_idx(8)><auditor_addr(20)><rewarded_moment_start_idx(8)><accumulated_reward(8)><locked_token_amount(8)><last_heartbeat_ledger_idx(8)> Note: <locked_token_amount(8)> -= <redeemed amount> 5. Redeem Error Transaction type: Payment Source: Host Destination: Hook Currency: XRP Amount: any Memo 1: Type: evnRedeemError Format: text/json Data: {type:'REDEEM_ERROR'} Memo 2: Type: evnRedeemRef Format: hex Data: <redeem tx hash> Generated transactions: Transaction type: Payment Source: Hook Destination: User Currency: XRP Amount: any Memo 1: Type: evnRedeemError Format: text/json Data: {type:'REDEEM_ERROR'} Memo 2: Type: evnRedeemRef Format: hex Data: <redeem tx hash> 6. Refund Transaction type: Payment Source: User Destination: Hook Currency: XRP Amount: any Memo: Type: evnRefund Format: hex Data: <redeem tx hash> Generated transactions: If success Transaction type: Payment Source: Hook Destination: User Currency: <hosting_token> Amount: <redeemed amount> Memo: Type: evnRefundSuccess Format: hex Data: <refund tx hash><redeem tx hash> If error Transaction type: Payment Source: Hook Destination: User Currency: XRP Amount: any Memo: Type: evnRefundError Format: hex Data: <refund tx hash> Deleted state: Key: STP_REDEEM_OP + Redeem tx hash Modified state: If success Key: STP_HOST_ADDR + host_addr Value: <host_id(4)><hosting_token(3)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><reserved(8)><description(26)><audit_assigned_moment_start_idx(8)><auditor_addr(20)><rewarded_moment_start_idx(8)><accumulated_reward(8)><locked_token_amount(8)><last_heartbeat_ledger_idx(8)> Note: <locked_token_amount(8)> -= <redeemed amount> 7. Audit Request Transaction type: Payment Source: Auditor Destination: Hook Currency: XRP Amount: any Memo: Type: evnAudit Format: <empty> Data: <reserved for future> Generated transactions: Transaction type: CheckCreate Source: Hook Destination: Auditor Currency: <hosting_token> Amount: CONF_MIN_REDEEM Memo: Type: evnAuditAssignment Format: <empty> Data: <reserved for future> Modified state: Key: STK_MOMENT_SEED Value: <moment_start_idx(8)><moment_seed(32)> Key: STP_AUDITOR_ADDR + auditor_addr Value: <auditor_id(4)><moment_start_idx(8)> Key: STP_HOST_ADDR + host_addr Value: <host_id(4)><hosting_token(3)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><reserved(8)><description(26)><audit_assigned_moment_start_idx(8)><auditor_addr(20)><rewarded_moment_start_idx(8)><accumulated_reward(8)><locked_token_amount(8)><last_heartbeat_ledger_idx(8)> Note: <auditor_addr(20)> of all the hosts which are getting assigned will be updated. The reward will append <rewarded_moment_start_idx(8)> . <accumulated_reward(8)> of all active hosts will get updated. Key: STK_ACCUMULATED_MOMENT_IDX Value: <moment_start_idx(8)> Note: This will get updated only if rewards are accumulated in this request. Key: STK_REWARD_POOL Value: <pool_amount(8)> Note: will be updated with host accumulations so far, if previous audits of a particular host does not has a reward. 8. Audit Success Transaction type: Payment Source: Auditor Destination: Hook Currency: XRP Amount: any Memo: Type: evnAuditSuccess Format: hex Data: <host_addr(20) Generated transactions: Transaction type: Payment Source: Hook Destination: Host Currency: EVR Amount: CONF_REWARD / HOST_COUNT Memo: Type: evnReward Format: <empty> Data: <reserved for future> Modified state: Key: STP_HOST_ADDR + host_addr Value: <host_id(4)><hosting_token(3)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><reserved(8)><description(26)><audit_assigned_moment_start_idx(8)><auditor_addr(20)><rewarded_moment_start_idx(8)><accumulated_reward(8)><locked_token_amount(8)><last_heartbeat_ledger_idx(8)> Note: <accumulated_reward(8)> = {0} . 8. Audit Failure Transaction type: Payment Source: Auditor Destination: Hook Currency: XRP Amount: any Memo: Type: evnAuditFailure Format: hex Data: <host_addr(20) Modified state: Key: STK_REWARD_POOL Value: <pool_amount(8)> Note: <pool_amount(8)> will be updated with host's <accumulated_reward(8)> . Key: STP_HOST_ADDR + host_addr Value: <host_id(4)><hosting_token(3)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><reserved(8)><description(26)><audit_assigned_moment_start_idx(8)><auditor_addr(20)><rewarded_moment_start_idx(8)><accumulated_reward(8)><locked_token_amount(8)><last_heartbeat_ledger_idx(8)> Note: <accumulated_reward(8)> = {0} . 8. Recharge Transaction type: Payment Source: Host Destination: Hook Currency: Hosting Token Min amount: CONF_MIN_REDEEM Memo: Type: evnRecharge Format: <empty> Data: <empty> Generated transactions: If current token balance in hook - (locked_token_amount + MIN_REDEEM * (CONF_HOST_HEARTBEAT_FREQ + 1))) > 0 Transaction type: Payment Source: Hook Destination: Host Currency: Hosting Token Amount: current token balance in hook - (locked_token_amount + MIN_REDEEM * (CONF_HOST_HEARTBEAT_FREQ + 1))) Modified state: Key: STP_HOST_ADDR + host_addr Value: <host_id(4)><hosting_token(3)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><reserved(8)><description(26)><audit_assigned_moment_start_idx(8)><auditor_addr(20)><rewarded_moment_start_idx(8)><accumulated_reward(8)><locked_token_amount(8)><last_heartbeat_ledger_idx(8)> Note: <last_heartbeat_ledger_idx(8)> = current ledger index .","title":"Hook"},{"location":"evernode/hook-spec/#evernode-hook-specification","text":"The following sections describe the specification according to which the Evernode hook has been developed. The hook source code can be found here .","title":"Evernode hook specification"},{"location":"evernode/hook-spec/#hook-state","text":"Evernode hook makes use of xrpl hook state to store persistent or short-lived variables. We use a 2-byte prefix for all state keys to avoid key naming collisions in the future with other hooks (this is a best-practice). See state clobbering .","title":"Hook State"},{"location":"evernode/hook-spec/#evernode-state-key-format","text":"[EVERNODE(EVR)(3)][key type(1)][Specific key bytes(28)] The first three bytes identifies that this is an Evernode state key. Fourth byte identifies the key type within Evernode. Rest of the 28 bytes contain the bytes specific for the key.","title":"Evernode state key format"},{"location":"evernode/hook-spec/#singleton-state-keys","text":"Description Key Host count (Maintains total no. of registered hosts) STK_HOST_COUNT = EVR[50]00000.... Auditor count (Maintains total no. of registered auditors) STK_AUDITOR_COUNT = EVR[51]00000.... Ledger index when the CONF_MOMENT_SIZE last changed on STK_MOMENT_BASE_IDX = EVR[52]0000.... Moment start index and the moment seed(ledger hash) for the current moment STK_MOMENT_SEED = EVR[53]0000.... Last moment start index where rewards have been accumulated STK_ACCUMULATED_MOMENT_IDX = EVR[54]0000.... Pool of reward amounts which are received on a audit failure STK_REWARD_POOL = EVR[55]0000....","title":"Singleton state keys"},{"location":"evernode/hook-spec/#repetitive-state-keys","text":"Description Prefix Configuration keys (Holds paramateres tunable by governance game) STP_CONF = EVR[1]... Host id keys (Host registration entries for id-based lookup) STP_HOST_ID = EVR[2]... Host address keys (Host registration entries for xrpl address-based lookup) STP_HOST_ADDR = EVR[3]... Auditor id keys (Auditor registration entries for id-based lookup) STP_AUDITOR_ID = EVR[4]... Auditor address keys (Auditor registration entries for xrpl address-based lookup) STP_AUDITOR_ADDR = EVR[5]... Redeem operation keys (Keys to hold ongoing redeem opration statuses) STP_REDEEM_OP = EVR[6]...","title":"Repetitive state keys"},{"location":"evernode/hook-spec/#hook-configuration","text":"Evernode hook defines a set of tunable configuration parameters to govern the rules of the system. They are implemented as xrpl hook sate objects. They can be changed in a decentralized manner via the governance game. Configuration Default value State key No. of ledgers per moment DEF_MOMENT_SIZE = 72 CONF_MOMENT_SIZE = 0x0001 No. of Evers that will be ever issued. DEF_MINT_LIMIT = 25804800 CONF_MINT_LIMIT = 0x0002 The host registration fee in Evers. DEF_HOST_REG_FEE = 5 CONF_HOST_REG_FEE = 0x0003 The minimum amount of hosting token spending allowed in a redeem operation. DEF_MIN_REDEEM = 12 CONF_MIN_REDEEM = 0x0004 Max no. of ledgers within which a redeem operation has to be serviced. DEF_REDEEM_WINDOW = 24 CONF_REDEEM_WINDOW = 0x0005 No. of Evers rewarded per moment. DEF_REWARD = 64 CONF_REWARD = 0x0006 Max no. of rewards per moment. DEF_MAX_REWARDS = 20 CONF_MAX_REWARD = 0x0007 No. of maximum hosts that can be audited by a audit per moment. DEF_MAX_AUDIT = 5 CONF_MAX_AUDIT = 0x0008 Moment frequency which host should keep recharging the hook (which used to track host aliveness). DEF_HOST_HEARTBEAT_FREQ = 1 CONF_HOST_HEARTBEAT_FREQ = 0x0009 Default auditor address DEF_AUDITOR_ADDR = 0x...xrpadrress bytes... N/A","title":"Hook Configuration"},{"location":"evernode/hook-spec/#about-configuration-state-keys","text":"State keys must be 32 bytes long. Therefore we must 'pad' the configuration state keys with zeros to fit 32 bytes. Therefore actual state key for a given configuration must be derived from a macro like this: CONF_KEY(buf, confKey) // which expands to: STATE_KEY(buf, prefix, key, keyLen) // which expands to: buf = prefix + pad + key","title":"About configuration state keys"},{"location":"evernode/hook-spec/#about-default-values","text":"Because the state values can only be \"initialized\" the first time they are used during a transaction processing, the default values must exist within the hook code. If a particular configuration value does not exist on the state, it has to be created with the default value indicated on the code.","title":"About default values"},{"location":"evernode/hook-spec/#system-operations","text":"Evernode uses XRPL transactions with attached memos to incorporate Evernode operation payloads. Evernode defines following operations.","title":"System Operations"},{"location":"evernode/hook-spec/#1-host-registration","text":"Transaction type: Payment Source: Host Destination: Hook Currency: EVR Min amount: CONF_HOST_REG_FEE Memo: Type: evnHostReg Format: text/plain Data: <hosting_token (UPPERCASE, 3 chars)>;<country_code (2 chars)>;<cpu_micro_sec (positive integer)>;<ram_mb (positive integer)>;<disk_mb (positive integer)>;<description (26 chars)>","title":"1. Host Registration"},{"location":"evernode/hook-spec/#generated-transactions","text":"Transaction type: Trust Set Source: Hook Destination: Host Currency: hosting_token Limit: 999999999","title":"Generated transactions:"},{"location":"evernode/hook-spec/#added-state","text":"Key: STP_HOST_ID + host_count + 1 value: <host_address(20)> Key: STP_HOST_ADDR + host_address Value: <host_id(4)><hosting_token(3)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><reserved(8)><description(26)> Note: The first audit cycle and redeem will append <audit_assigned_moment_start_idx(8)><auditor_addr(20)><rewarded_moment_start_idx(8)><accumulated_reward(8)><locked_token_amount(8)><last_heartbeat_ledger_idx(8)> to this state value.","title":"Added state:"},{"location":"evernode/hook-spec/#modified-state","text":"Key: STK_HOST_COUNT Value: <new_host_count(4)>","title":"Modified state:"},{"location":"evernode/hook-spec/#2-host-deregistration","text":"Transaction type: Payment Source: Host Destination: Hook Currency: XRP Amount: Any Memo: Type: evnHostDereg Format: any Data: any","title":"2. Host deregistration"},{"location":"evernode/hook-spec/#generated-transactions_1","text":"Transaction type: Payment Source: Hook Destination: Host Currency: hosting_token Amount: Available balance Transaction type: Trust Set Source: Hook Destination: Host Currency: hosting_token Limit: 0","title":"Generated transactions:"},{"location":"evernode/hook-spec/#modified-state_1","text":"Key: STP_HOST_ID + deleted_host_id Value: <last_host_addr> Key: STP_HOST_ADDR + last_host_addr Value: <deleted_host_id(4)><...> Key: STK_HOST_COUNT Value: host_count - 1","title":"Modified state:"},{"location":"evernode/hook-spec/#deleted-state","text":"Key: STP_HOST_ADDR + host_address Key: STP_HOST_ID + last_host_id","title":"Deleted state:"},{"location":"evernode/hook-spec/#3-redeem","text":"Transaction type: Payment Source: User Destination: Hook Currency: Anything other than XRP or EVR Min amount: CONF_MIN_REDEEM Memo: Type: evnRedeem Format: base64 Data: <encrypted instance requirements>","title":"3. Redeem"},{"location":"evernode/hook-spec/#generated-transactions_2","text":"Transaction type: Payment Source: Hook Destination: Host Currency: XRP Amount: any Memo 1: Type: evnRedeem Format: base64 Data: <encrypted instance requirements> Memo 2: Type: evnRedeemOrigin Format: hex Data: <user_addr(20)<amount(8)><hosting_token(3)><redeem_tx_hash(32)>","title":"Generated transactions:"},{"location":"evernode/hook-spec/#added-state_1","text":"Key: STP_REDEEM_OP + Redeem tx hash Value: <hosting_token(3)><amount(8)><host_addr(20)><lcl_index(8)><user_addr(20)>","title":"Added state:"},{"location":"evernode/hook-spec/#modified-state_2","text":"Key: STP_HOST_ADDR + host_addr Value: <host_id(4)><hosting_token(3)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><reserved(8)><description(26)><audit_assigned_moment_start_idx(8)><auditor_addr(20)><rewarded_moment_start_idx(8)><accumulated_reward(8)><locked_token_amount(8)><last_heartbeat_ledger_idx(8)> Note: <locked_token_amount(8)> += <amount(8)>","title":"Modified state:"},{"location":"evernode/hook-spec/#4-redeem-success","text":"Transaction type: Payment Source: Host Destination: Hook Currency: XRP Amount: any Memo 1: Type: evnRedeemSuccess Format: base64 Data: <encrypted instance_data> Memo 2: Type: evnRedeemRef Format: hex Data: <redeem tx hash>","title":"4. Redeem Success"},{"location":"evernode/hook-spec/#generated-transactions_3","text":"Transaction type: Payment Source: Hook Destination: User Currency: XRP Amount: any Memo 1: Type: evnRedeemSuccess Format: base64 Data: <encrypted instance_data> Memo 2: Type: evnRedeemRef Format: hex Data: <redeem tx hash> Transaction type: Payment Source: Hook Destination: Host Currency: <hosting_token> Amount: <redeemed amount>","title":"Generated transactions:"},{"location":"evernode/hook-spec/#deleted-state_1","text":"Key: STP_REDEEM_OP + Redeem tx hash","title":"Deleted state:"},{"location":"evernode/hook-spec/#modified-state_3","text":"Key: STP_HOST_ADDR + host_addr Value: <host_id(4)><hosting_token(3)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><reserved(8)><description(26)><audit_assigned_moment_start_idx(8)><auditor_addr(20)><rewarded_moment_start_idx(8)><accumulated_reward(8)><locked_token_amount(8)><last_heartbeat_ledger_idx(8)> Note: <locked_token_amount(8)> -= <redeemed amount>","title":"Modified state:"},{"location":"evernode/hook-spec/#5-redeem-error","text":"Transaction type: Payment Source: Host Destination: Hook Currency: XRP Amount: any Memo 1: Type: evnRedeemError Format: text/json Data: {type:'REDEEM_ERROR'} Memo 2: Type: evnRedeemRef Format: hex Data: <redeem tx hash>","title":"5. Redeem Error"},{"location":"evernode/hook-spec/#generated-transactions_4","text":"Transaction type: Payment Source: Hook Destination: User Currency: XRP Amount: any Memo 1: Type: evnRedeemError Format: text/json Data: {type:'REDEEM_ERROR'} Memo 2: Type: evnRedeemRef Format: hex Data: <redeem tx hash>","title":"Generated transactions:"},{"location":"evernode/hook-spec/#6-refund","text":"Transaction type: Payment Source: User Destination: Hook Currency: XRP Amount: any Memo: Type: evnRefund Format: hex Data: <redeem tx hash>","title":"6. Refund"},{"location":"evernode/hook-spec/#generated-transactions_5","text":"If success Transaction type: Payment Source: Hook Destination: User Currency: <hosting_token> Amount: <redeemed amount> Memo: Type: evnRefundSuccess Format: hex Data: <refund tx hash><redeem tx hash> If error Transaction type: Payment Source: Hook Destination: User Currency: XRP Amount: any Memo: Type: evnRefundError Format: hex Data: <refund tx hash>","title":"Generated transactions:"},{"location":"evernode/hook-spec/#deleted-state_2","text":"Key: STP_REDEEM_OP + Redeem tx hash","title":"Deleted state:"},{"location":"evernode/hook-spec/#modified-state_4","text":"If success Key: STP_HOST_ADDR + host_addr Value: <host_id(4)><hosting_token(3)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><reserved(8)><description(26)><audit_assigned_moment_start_idx(8)><auditor_addr(20)><rewarded_moment_start_idx(8)><accumulated_reward(8)><locked_token_amount(8)><last_heartbeat_ledger_idx(8)> Note: <locked_token_amount(8)> -= <redeemed amount>","title":"Modified state:"},{"location":"evernode/hook-spec/#7-audit-request","text":"Transaction type: Payment Source: Auditor Destination: Hook Currency: XRP Amount: any Memo: Type: evnAudit Format: <empty> Data: <reserved for future>","title":"7. Audit Request"},{"location":"evernode/hook-spec/#generated-transactions_6","text":"Transaction type: CheckCreate Source: Hook Destination: Auditor Currency: <hosting_token> Amount: CONF_MIN_REDEEM Memo: Type: evnAuditAssignment Format: <empty> Data: <reserved for future>","title":"Generated transactions:"},{"location":"evernode/hook-spec/#modified-state_5","text":"Key: STK_MOMENT_SEED Value: <moment_start_idx(8)><moment_seed(32)> Key: STP_AUDITOR_ADDR + auditor_addr Value: <auditor_id(4)><moment_start_idx(8)> Key: STP_HOST_ADDR + host_addr Value: <host_id(4)><hosting_token(3)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><reserved(8)><description(26)><audit_assigned_moment_start_idx(8)><auditor_addr(20)><rewarded_moment_start_idx(8)><accumulated_reward(8)><locked_token_amount(8)><last_heartbeat_ledger_idx(8)> Note: <auditor_addr(20)> of all the hosts which are getting assigned will be updated. The reward will append <rewarded_moment_start_idx(8)> . <accumulated_reward(8)> of all active hosts will get updated. Key: STK_ACCUMULATED_MOMENT_IDX Value: <moment_start_idx(8)> Note: This will get updated only if rewards are accumulated in this request. Key: STK_REWARD_POOL Value: <pool_amount(8)> Note: will be updated with host accumulations so far, if previous audits of a particular host does not has a reward.","title":"Modified state:"},{"location":"evernode/hook-spec/#8-audit-success","text":"Transaction type: Payment Source: Auditor Destination: Hook Currency: XRP Amount: any Memo: Type: evnAuditSuccess Format: hex Data: <host_addr(20)","title":"8. Audit Success"},{"location":"evernode/hook-spec/#generated-transactions_7","text":"Transaction type: Payment Source: Hook Destination: Host Currency: EVR Amount: CONF_REWARD / HOST_COUNT Memo: Type: evnReward Format: <empty> Data: <reserved for future>","title":"Generated transactions:"},{"location":"evernode/hook-spec/#modified-state_6","text":"Key: STP_HOST_ADDR + host_addr Value: <host_id(4)><hosting_token(3)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><reserved(8)><description(26)><audit_assigned_moment_start_idx(8)><auditor_addr(20)><rewarded_moment_start_idx(8)><accumulated_reward(8)><locked_token_amount(8)><last_heartbeat_ledger_idx(8)> Note: <accumulated_reward(8)> = {0} .","title":"Modified state:"},{"location":"evernode/hook-spec/#8-audit-failure","text":"Transaction type: Payment Source: Auditor Destination: Hook Currency: XRP Amount: any Memo: Type: evnAuditFailure Format: hex Data: <host_addr(20)","title":"8. Audit Failure"},{"location":"evernode/hook-spec/#modified-state_7","text":"Key: STK_REWARD_POOL Value: <pool_amount(8)> Note: <pool_amount(8)> will be updated with host's <accumulated_reward(8)> . Key: STP_HOST_ADDR + host_addr Value: <host_id(4)><hosting_token(3)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><reserved(8)><description(26)><audit_assigned_moment_start_idx(8)><auditor_addr(20)><rewarded_moment_start_idx(8)><accumulated_reward(8)><locked_token_amount(8)><last_heartbeat_ledger_idx(8)> Note: <accumulated_reward(8)> = {0} .","title":"Modified state:"},{"location":"evernode/hook-spec/#8-recharge","text":"Transaction type: Payment Source: Host Destination: Hook Currency: Hosting Token Min amount: CONF_MIN_REDEEM Memo: Type: evnRecharge Format: <empty> Data: <empty>","title":"8. Recharge"},{"location":"evernode/hook-spec/#generated-transactions_8","text":"If current token balance in hook - (locked_token_amount + MIN_REDEEM * (CONF_HOST_HEARTBEAT_FREQ + 1))) > 0 Transaction type: Payment Source: Hook Destination: Host Currency: Hosting Token Amount: current token balance in hook - (locked_token_amount + MIN_REDEEM * (CONF_HOST_HEARTBEAT_FREQ + 1)))","title":"Generated transactions:"},{"location":"evernode/hook-spec/#modified-state_8","text":"Key: STP_HOST_ADDR + host_addr Value: <host_id(4)><hosting_token(3)><country_code(2)><cpu_microsec(4)><ram_mb(4)><disk_mb(4)><reserved(8)><description(26)><audit_assigned_moment_start_idx(8)><auditor_addr(20)><rewarded_moment_start_idx(8)><accumulated_reward(8)><locked_token_amount(8)><last_heartbeat_ledger_idx(8)> Note: <last_heartbeat_ledger_idx(8)> = current ledger index .","title":"Modified state:"},{"location":"hot-pocket/","text":"Hot Pocket Hot Pocket is a decentralized app (Dapp) development platform. Your can build your app as a \"Smart Contract\" which runs on a distributed Hot Pocket cluster. Hot Pocket takes care of running instances of your smart contract on all the nodes and perform \"consensus\" on your smart contract executions. Smart Contract Hot Pocket defines the smart contract as a regular POSIX application that can receive Inputs , produce Outputs and also persist State to permenant storage. You can use any programming language to create Hot Pocket smart contracts. Consensus Because your smart contract instances simultaneously runs on multiple nodes, it needs to be verified that all instances execute under exact same conditions and in the same manner. Hot Pocket makes sure that the MAJORITY of the instances receives the same inputs , produces same outputs and persists same state to the permanent storage. This is known as consensus in which majority of instances AGREE upon similar behavior of the smart contract. Security aspect The benefit of consensus is that in order for an intruder to arbitrarily change the behavior of the smart contract or to forcefully tamper the persisted state, they need to be able to do that to a MAJORITY of the instances at the same time, which is practically impossible. If one of the instances gets compromised, the consensus would detect it and apply corrections to the compromised instance. Decentralized control If different instances of the smart contract is owned by multiple parties (eg. different people or organizations), then no single party has ultimate control over the entire cluster. No single party can manipulate the system. It would require collaboration of majority of owners to manipulate the entire system's behaviour in order to make collective modifications to the instances owned by them at the same time . Users You can \"connect\" to any ONE of the smart contract instances of the custer and communicate with that instance as a \"user\" (Hot Pocket will subject your communication with that particular instance to inter-node consensus which is hidden from you). For Hot Pocket to distinguish you with other users who are connecting to the same cluster, you need to identify yourself with a unique Public/Private asymmetric key pair (generated using EdDSA signing key algorithm). Upon successful connection, you can communicate with the smart contract using the app-specific message formats defined by the smart contract developer. Hot Pocket acts as a \"carrier\" of messages between you and the smart contract. See User connection basics Hot Pocket SDKs Hot Pocket provides several libraries to make it easy to write Hot Pocket smart contracts and to connect and communicate with Hot Pocket smart contracts as a user. Library for NodeJs contracts Library for Javascript clients","title":"Hot Pocket"},{"location":"hot-pocket/#hot-pocket","text":"Hot Pocket is a decentralized app (Dapp) development platform. Your can build your app as a \"Smart Contract\" which runs on a distributed Hot Pocket cluster. Hot Pocket takes care of running instances of your smart contract on all the nodes and perform \"consensus\" on your smart contract executions.","title":"Hot Pocket"},{"location":"hot-pocket/#smart-contract","text":"Hot Pocket defines the smart contract as a regular POSIX application that can receive Inputs , produce Outputs and also persist State to permenant storage. You can use any programming language to create Hot Pocket smart contracts.","title":"Smart Contract"},{"location":"hot-pocket/#consensus","text":"Because your smart contract instances simultaneously runs on multiple nodes, it needs to be verified that all instances execute under exact same conditions and in the same manner. Hot Pocket makes sure that the MAJORITY of the instances receives the same inputs , produces same outputs and persists same state to the permanent storage. This is known as consensus in which majority of instances AGREE upon similar behavior of the smart contract.","title":"Consensus"},{"location":"hot-pocket/#security-aspect","text":"The benefit of consensus is that in order for an intruder to arbitrarily change the behavior of the smart contract or to forcefully tamper the persisted state, they need to be able to do that to a MAJORITY of the instances at the same time, which is practically impossible. If one of the instances gets compromised, the consensus would detect it and apply corrections to the compromised instance.","title":"Security aspect"},{"location":"hot-pocket/#decentralized-control","text":"If different instances of the smart contract is owned by multiple parties (eg. different people or organizations), then no single party has ultimate control over the entire cluster. No single party can manipulate the system. It would require collaboration of majority of owners to manipulate the entire system's behaviour in order to make collective modifications to the instances owned by them at the same time .","title":"Decentralized control"},{"location":"hot-pocket/#users","text":"You can \"connect\" to any ONE of the smart contract instances of the custer and communicate with that instance as a \"user\" (Hot Pocket will subject your communication with that particular instance to inter-node consensus which is hidden from you). For Hot Pocket to distinguish you with other users who are connecting to the same cluster, you need to identify yourself with a unique Public/Private asymmetric key pair (generated using EdDSA signing key algorithm). Upon successful connection, you can communicate with the smart contract using the app-specific message formats defined by the smart contract developer. Hot Pocket acts as a \"carrier\" of messages between you and the smart contract. See User connection basics","title":"Users"},{"location":"hot-pocket/#hot-pocket-sdks","text":"Hot Pocket provides several libraries to make it easy to write Hot Pocket smart contracts and to connect and communicate with Hot Pocket smart contracts as a user. Library for NodeJs contracts Library for Javascript clients","title":"Hot Pocket SDKs"},{"location":"hot-pocket/user-connections/","text":"Hot Pocket user connection basics Hot Pocket smart contracts are run as a cluster of nodes. As a user, you can connect to any one of the nodes and communicate with the smart contract. User public/private key pair You need to posses a unique public/private assymetric key pair generated using EdDSA signing key algorithm. You can use a suitable cryptographic library available on your platform in order to generate a key pair. Client libraries provided by Hot Pocket also contains helper methods which can do this. It is the user's responsibility to not let the \"Private Key\" get compromised. If that happens, anyone possessing your Private Key can pretend to be you. On the flip side, if you lose your Private Key, you will be unable to reclaim your user identity on the Hot Pocket platform Making a connection In order to initiate a connection to a smart contract instance, you need to know the address and the port number of where that instances is hosted. See this Javascript example on how to connect and communicate with a smart contract instance. Submitting inputs Hot Pocket defines \"Inputs\" as the messages you (user) send to the smart contract which has the potential to modify the smart contract state (similar to HTTP PUT/POST methods). \"Inputs\" are subjected to \"consensus\" (see Hot Pocket basics) and therefore may take longer to be processed. The reason being, even though you submitted the \"Input\" to a specific Hot Pocket instance (denoted by host address and port), it will propagate this to other nodes. As a group, all the instances in the cluster makes sure \"majority\" of them got the input. Once the above condition (majority instances has received your input) is met, you will get a \"Accepted\" response. This indicates your \"Input\" got accepted for processing by the entire cluster. However, there are various reasons that your \"Input\" can be \"Rejected\" as well which will not be explained here. Note: Unlike HTTP Rest APIs, it is wrong to assume every 'input' message will get a 'output' message as the response. It is up to the smart contract to decide whether to send a response message or not. If the smart contract actually sends such a response back, it will arrive much later than the \"Accepted\" response you got upon input submission. This is very different from how HTTP APIs work where a 'request' will get a immediate 'response'. This is mainly due to Hot Pocket operating on top of Web Sockets as opposed to HTTP. Receiving outputs \"Outputs\" are messages sent by the smart contract to the user. \"Outputs\" might be sent as a response to previously submitted \"Inputs\" or they might be delivered without any relationship to a previous \"Input\" (eg. periodic notification messages sent by a smart contract). It is up to the smart contract to decide when and where to send outputs. If the smart contract message format specifies that a particular input message will get a response, then it is up to you to wait and grab that response when it arrives. Hot Pocket client library makes this easy (see Javascript example for output capture ). Read requests Hot Pocket \"Read requests\" are very similar to HTTP GET method. They represent any messages that request information from the smart contract and that DOES NOT modify the smart contract state (read only). They are NOT subjected to consensus and are very much faster in their response time as opposed to \"Inputs/Outputs\". Unlike \"Inputs/Outputs\", Read Requests also follow similar request/response pattern like HTTP. Those qualities make them the ideal mechanism to read information out of the smart contract. Binary vs Text Protocols Hot Pocket supports binary vs text-mode communication protocols. If the smart contract uses text-based (eg. json) messages, then you should use the Hot Pocket json protocol. Otherwise Hot Pocket supports bson protocol. You can specify this in Hot Pocket client library ( Javascript example )","title":"Hot Pocket user connection basics"},{"location":"hot-pocket/user-connections/#hot-pocket-user-connection-basics","text":"Hot Pocket smart contracts are run as a cluster of nodes. As a user, you can connect to any one of the nodes and communicate with the smart contract.","title":"Hot Pocket user connection basics"},{"location":"hot-pocket/user-connections/#user-publicprivate-key-pair","text":"You need to posses a unique public/private assymetric key pair generated using EdDSA signing key algorithm. You can use a suitable cryptographic library available on your platform in order to generate a key pair. Client libraries provided by Hot Pocket also contains helper methods which can do this. It is the user's responsibility to not let the \"Private Key\" get compromised. If that happens, anyone possessing your Private Key can pretend to be you. On the flip side, if you lose your Private Key, you will be unable to reclaim your user identity on the Hot Pocket platform","title":"User public/private key pair"},{"location":"hot-pocket/user-connections/#making-a-connection","text":"In order to initiate a connection to a smart contract instance, you need to know the address and the port number of where that instances is hosted. See this Javascript example on how to connect and communicate with a smart contract instance.","title":"Making a connection"},{"location":"hot-pocket/user-connections/#submitting-inputs","text":"Hot Pocket defines \"Inputs\" as the messages you (user) send to the smart contract which has the potential to modify the smart contract state (similar to HTTP PUT/POST methods). \"Inputs\" are subjected to \"consensus\" (see Hot Pocket basics) and therefore may take longer to be processed. The reason being, even though you submitted the \"Input\" to a specific Hot Pocket instance (denoted by host address and port), it will propagate this to other nodes. As a group, all the instances in the cluster makes sure \"majority\" of them got the input. Once the above condition (majority instances has received your input) is met, you will get a \"Accepted\" response. This indicates your \"Input\" got accepted for processing by the entire cluster. However, there are various reasons that your \"Input\" can be \"Rejected\" as well which will not be explained here. Note: Unlike HTTP Rest APIs, it is wrong to assume every 'input' message will get a 'output' message as the response. It is up to the smart contract to decide whether to send a response message or not. If the smart contract actually sends such a response back, it will arrive much later than the \"Accepted\" response you got upon input submission. This is very different from how HTTP APIs work where a 'request' will get a immediate 'response'. This is mainly due to Hot Pocket operating on top of Web Sockets as opposed to HTTP.","title":"Submitting inputs"},{"location":"hot-pocket/user-connections/#receiving-outputs","text":"\"Outputs\" are messages sent by the smart contract to the user. \"Outputs\" might be sent as a response to previously submitted \"Inputs\" or they might be delivered without any relationship to a previous \"Input\" (eg. periodic notification messages sent by a smart contract). It is up to the smart contract to decide when and where to send outputs. If the smart contract message format specifies that a particular input message will get a response, then it is up to you to wait and grab that response when it arrives. Hot Pocket client library makes this easy (see Javascript example for output capture ).","title":"Receiving outputs"},{"location":"hot-pocket/user-connections/#read-requests","text":"Hot Pocket \"Read requests\" are very similar to HTTP GET method. They represent any messages that request information from the smart contract and that DOES NOT modify the smart contract state (read only). They are NOT subjected to consensus and are very much faster in their response time as opposed to \"Inputs/Outputs\". Unlike \"Inputs/Outputs\", Read Requests also follow similar request/response pattern like HTTP. Those qualities make them the ideal mechanism to read information out of the smart contract.","title":"Read requests"},{"location":"hot-pocket/user-connections/#binary-vs-text-protocols","text":"Hot Pocket supports binary vs text-mode communication protocols. If the smart contract uses text-based (eg. json) messages, then you should use the Hot Pocket json protocol. Otherwise Hot Pocket supports bson protocol. You can specify this in Hot Pocket client library ( Javascript example )","title":"Binary vs Text Protocols"},{"location":"sashimono/","text":"Sashimono Sashimono is the software which runs on all Evernode hosts managing the Hot Pocket smart contract instances running on each host. It handles incoming hosting requests (redeems) and provisions Hot Pocket contract instances in secure silos using Docker containers.","title":"Sashimono"},{"location":"sashimono/#sashimono","text":"Sashimono is the software which runs on all Evernode hosts managing the Hot Pocket smart contract instances running on each host. It handles incoming hosting requests (redeems) and provisions Hot Pocket contract instances in secure silos using Docker containers.","title":"Sashimono"}]}